<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>faicker&#39;s个人博客</title>
  <subtitle>关注云计算，网络虚拟化</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.motitan.com/"/>
  <updated>2017-06-06T08:18:20.000Z</updated>
  <id>http://blog.motitan.com/</id>
  
  <author>
    <name>faicker</name>
    <email>faicker.mo@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python package and deploy</title>
    <link href="http://blog.motitan.com/2017/06/06/python-package-and-deploy/"/>
    <id>http://blog.motitan.com/2017/06/06/python-package-and-deploy/</id>
    <published>2017-06-06T07:55:00.000Z</published>
    <updated>2017-06-06T08:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>python 打包和部署对于开源项目来说，pip/pypi 就足够了。但是对于公司线上的程序部署，有各种包依赖关系，需要做到依赖包隔离，程序版本管理，部署方式一致化。使用 docker 是很流行，并且通用的方式。还有没有更轻量的方式呢？这就是本文将介绍的内容。</p>
<p>一般来说，一个公司的线上系统版本是一致的，随系统发行版本带的 python 版本也是一致的。如果要跑不同的 python 版本，docker 是一个选择。这里讨论版本一致的情况。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>用到了以下工具，</p>
<ul>
<li><a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="external">virtualenv</a>，包隔离</li>
<li><a href="https://github.com/jordansissel/fpm" target="_blank" rel="external">fpm</a>，打包工具，支持打包成 rpm/deb/osxpkg 等。</li>
</ul>
<p>用 virtualenv 来做依赖包隔离，包含了自己的程序和依赖的包；系统自带的包管理工具（centos 是 rpm）来做版本管理，实现包的更新，回退。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="fpm-安装（centos6-下为例）"><a href="#fpm-安装（centos6-下为例）" class="headerlink" title="fpm 安装（centos6 下为例）"></a>fpm 安装（centos6 下为例）</h4><ul>
<li>安装 virtualenv-tools。<br><code>pip install virtualenv-tools</code></li>
<li>安装 ruby（&gt;=1.9.3），用到了 <a href="https://www.softwarecollections.org/en/" target="_blank" rel="external">scl</a>。<br><code>yum install rh-ruby23-ruby rh-ruby23-ruby-devel</code><br><code>scl enable rh-ruby23 bash</code></li>
<li>安装 fpm。<br><code>gem install fpm</code></li>
</ul>
<h4 id="python项目"><a href="#python项目" class="headerlink" title="python项目"></a>python项目</h4><p>可以参考 <a href="https://github.com/faicker/pychinadns" target="_blank" rel="external">pychinadns</a>，需要写 setup.py。</p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p><code>fpm --verbose -f -v 0.1.0 -n flowcleaner -s virtualenv -t rpm --virtualenv-pypi http://mirrors.aliyun.com/pypi/simple flowcleaner/</code><br>-s 指定源类型，-t 指定目标类型，-n 指定包名，flowcleaner/ 是项目目录。<br>会把整个 virtualenv 的目录打包到rpm里，virtualenv 里包含了依赖的包。</p>
<h4 id="部署和运行"><a href="#部署和运行" class="headerlink" title="部署和运行"></a>部署和运行</h4><p>部署就是一个rpm包！跟标准的rpm包操作一样。</p>
<p>rpm 安装时，virtualenv 默认安装在 /usr/share/python 目录下。<br>执行<code>/usr/share/python/flowcleaner/bin/python xxx.py</code>来从 virtualenv 里运行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;python 打包和部署对于开源项目来说，pip/pypi 就足够了。但是对于公司线上的程序部署，有各种包依赖关系，需要做到依赖包隔离，程序
    
    </summary>
    
      <category term="python" scheme="http://blog.motitan.com/categories/python/"/>
    
      <category term="deploy" scheme="http://blog.motitan.com/categories/python/deploy/"/>
    
    
      <category term="python" scheme="http://blog.motitan.com/tags/python/"/>
    
      <category term="virtualenv" scheme="http://blog.motitan.com/tags/virtualenv/"/>
    
      <category term="fpm" scheme="http://blog.motitan.com/tags/fpm/"/>
    
  </entry>
  
  <entry>
    <title>python性能分析工具之pyflame</title>
    <link href="http://blog.motitan.com/2017/04/15/python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%B9%8Bpyflame/"/>
    <id>http://blog.motitan.com/2017/04/15/python性能分析工具之pyflame/</id>
    <published>2017-04-15T14:30:00.000Z</published>
    <updated>2017-04-16T04:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章<a href="http://www.cnblogs.com/xybaby/p/6510941.html" target="_blank" rel="external">python性能优化</a>总结的比较好，可以先看这篇的介绍。</p>
<p>里面介绍了针对不同场景使用的工具，</p>
<blockquote>
<p>对于python程序，比较出名的profile工具有三个：profile、cprofile和hotshot。<br>其中profile是纯python语言实现的，Cprofile将profile的部分实现native化，hotshot也是C语言实现，hotshot与Cprofile的区别在于：hotshot对目标代码的运行影响较小，代价是更多的后处理时间，而且hotshot已经停止维护了。需要注意的是，profile（Cprofile hotshot）只适合单线程的python程序。<br>对于多线程，可以使用yappi，yappi不仅支持多线程，还可以精确到CPU时间<br>对于协程（greenlet），可以使用greenletprofiler，基于yappi修改，用greenlet context hook住thread context。</p>
</blockquote>
<p>profile的结果可以用<a href="https://github.com/jrfonseca/gprof2dot" target="_blank" rel="external">gprof2dot</a>生成函数调用开销图，进行分析。</p>
<p>这里介绍另外一个好用的工具pyflame。对单线程，多线程，协程支持都很好，使用简单，不用修改源码，直接profile运行的进程。效率较高，进程运行只会慢3倍左右，建议非线上环境使用。最最关键的是可以直接生成<a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="external">火焰图</a>，具体介绍可以看github链接<a href="https://github.com/uber/pyflame" target="_blank" rel="external">pyflame</a>。<br>火焰图怎么看先google学习下，比gprof2dot的图更清晰明了。</p>
<hr>
<p>pyflame的安装步骤在github上介绍的很详细，对centos7也是适用的。这里介绍下内核较老的centos6+python2.6下面的安装（是一个C API 缺失<a href="http://hustcat.github.io/setns/" target="_blank" rel="external">setns</a>）。<br><a id="more"></a></p>
<ol>
<li>下载源码，<code>git clone https://github.com/faicker/pyflame</code></li>
<li><p>安装编译环境（高版本gcc和autoconf）及依赖包，</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yum install centos-release-scl</div><div class="line">yum install devtoolset-3-gcc devtoolset-3-gcc-c++</div><div class="line">rpm -ivh https://www.softwarecollections.org/en/scls/praiskup/autotools/epel-6-x86_64/download/praiskup-autotools-epel-6-x86_64.noarch.rpm</div><div class="line">yum install autotools-latest</div><div class="line">yum install python-devel</div></pre></td></tr></table></figure>
</li>
<li><p>编辑文件<code>/usr/lib64/pkgconfig/python2.pc</code></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">prefix=/usr</div><div class="line">exec_prefix=/usr</div><div class="line">libdir=/usr/lib64</div><div class="line">includedir=/usr/include</div><div class="line">Name: Python</div><div class="line">Description: Python library</div><div class="line">Requires:</div><div class="line">Version: 2.6</div><div class="line">Libs.private: -lpthread -ldl  -lutil</div><div class="line">Libs: -L<span class="variable">$&#123;libdir&#125;</span> -lpython2.6</div><div class="line">Cflags: -I<span class="variable">$&#123;includedir&#125;</span>/python2.6</div></pre></td></tr></table></figure>
</li>
<li><p>编译，</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scl <span class="built_in">enable</span> devtoolset-3 bash</div><div class="line">scl <span class="built_in">enable</span> autotools-latest bash</div><div class="line">./autogen.sh</div><div class="line">./configure</div><div class="line">make</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Enjoy.</p>
<p>注意点：</p>
<ul>
<li>profile eventlet程序时，要把结果里出现次数最多（比采样次数还多）的tpool.py:tworker:75的堆栈删掉。</li>
<li>svg文件可以用浏览器比如chrome打开。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/6510941.html&quot;&gt;python性能优化&lt;/a&gt;总结的比较好，可以先看这篇的介绍。&lt;/p&gt;
&lt;p&gt;里面介绍了针对不同场景使用的工具，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于python程序，比较出名的profile工具有三个：profile、cprofile和hotshot。&lt;br&gt;其中profile是纯python语言实现的，Cprofile将profile的部分实现native化，hotshot也是C语言实现，hotshot与Cprofile的区别在于：hotshot对目标代码的运行影响较小，代价是更多的后处理时间，而且hotshot已经停止维护了。需要注意的是，profile（Cprofile hotshot）只适合单线程的python程序。&lt;br&gt;对于多线程，可以使用yappi，yappi不仅支持多线程，还可以精确到CPU时间&lt;br&gt;对于协程（greenlet），可以使用greenletprofiler，基于yappi修改，用greenlet context hook住thread context。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;profile的结果可以用&lt;a href=&quot;https://github.com/jrfonseca/gprof2dot&quot;&gt;gprof2dot&lt;/a&gt;生成函数调用开销图，进行分析。&lt;/p&gt;
&lt;p&gt;这里介绍另外一个好用的工具pyflame。对单线程，多线程，协程支持都很好，使用简单，不用修改源码，直接profile运行的进程。效率较高，进程运行只会慢3倍左右，建议非线上环境使用。最最关键的是可以直接生成&lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;火焰图&lt;/a&gt;，具体介绍可以看github链接&lt;a href=&quot;https://github.com/uber/pyflame&quot;&gt;pyflame&lt;/a&gt;。&lt;br&gt;火焰图怎么看先google学习下，比gprof2dot的图更清晰明了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;pyflame的安装步骤在github上介绍的很详细，对centos7也是适用的。这里介绍下内核较老的centos6+python2.6下面的安装（是一个C API 缺失&lt;a href=&quot;http://hustcat.github.io/setns/&quot;&gt;setns&lt;/a&gt;）。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.motitan.com/categories/python/"/>
    
      <category term="pyflame" scheme="http://blog.motitan.com/categories/python/pyflame/"/>
    
      <category term="profile" scheme="http://blog.motitan.com/categories/python/pyflame/profile/"/>
    
    
      <category term="python" scheme="http://blog.motitan.com/tags/python/"/>
    
      <category term="pyflame" scheme="http://blog.motitan.com/tags/pyflame/"/>
    
      <category term="profile" scheme="http://blog.motitan.com/tags/profile/"/>
    
  </entry>
  
  <entry>
    <title>install openvswitch 2.7.0 and ovn on centos 7</title>
    <link href="http://blog.motitan.com/2017/03/11/install-openvswitch2.7.0-and-ovn-on-centos7/"/>
    <id>http://blog.motitan.com/2017/03/11/install-openvswitch2.7.0-and-ovn-on-centos7/</id>
    <published>2017-03-11T03:55:00.000Z</published>
    <updated>2017-03-11T04:31:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要参考此安装文档 <a href="http://docs.openvswitch.org/en/latest/intro/install/fedora/" target="_blank" rel="external">http://docs.openvswitch.org/en/latest/intro/install/fedora/</a><br>不过此文档只适用于fedora。</p>
<h3 id="rpm编译"><a href="#rpm编译" class="headerlink" title="rpm编译"></a>rpm编译</h3><p>在centos7上编译过程如下：</p>
<ol>
<li><p>安装依赖包</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install rpm-build autoconf automake libtool systemd-units openssl openssl-devel python-devel groff graphviz desktop-file-utils python-twisted python-zope-interface python-six procps-ng checkpolicy selinux-policy-devel libcap-ng libcap-ng-devel</div></pre></td></tr></table></figure>
</li>
<li><p>安装额外的依赖包python3-devel。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm</div><div class="line">yum install python3-devel</div></pre></td></tr></table></figure>
</li>
<li><p>如果要支持ovs-dpdk，</p>
<ul>
<li>安装dpdk 16.11，rpm包地址 <a href="[https://cbs.centos.org/koji/buildinfo?buildID=15283">https://cbs.centos.org/koji/buildinfo?buildID=15283</a></li>
<li><code>yum install numactl-devel libpcap-devel</code></li>
</ul>
</li>
<li><p>初始化环境</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar xf openvswitch-2.7.0.tar.gz</div><div class="line"><span class="built_in">cd</span> openvswitch-2.7.0</div><div class="line">./boot.sh</div><div class="line">./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc</div></pre></td></tr></table></figure>
</li>
<li><p>生成用户态rpm包，</p>
<ul>
<li><p>如果不需要dpdk，把–with dpdk去掉。同时，这里去掉了测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make rpm-fedora RPMBUILD_OPT=<span class="string">"--with dpdk --without check"</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>生成内核态rpm包，</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make rpm-fedora-kmod</div></pre></td></tr></table></figure>
</li>
</ol>
<p>生成的包在<code>rpm/rpmbuild/RPMS</code>下，包括ovn相关的。如果只想体验ovs，安装<code>openvswitch-2.7.0-1.el7.centos.x86_64.rpm</code>和<code>openvswitch-kmod-2.7.0-1.el7.centos.x86_64.rpm</code>即可。</p>
<h3 id="rpm安装时的注意事项"><a href="#rpm安装时的注意事项" class="headerlink" title="rpm安装时的注意事项"></a>rpm安装时的注意事项</h3><ul>
<li>如果安装rpm时，提示没有依赖包<code>python2-six/python2-twisted/python2-zope-interface</code>，加参数<code>--nodep</code>跳过依赖（前面其实已经安装了<code>python-six</code>等）</li>
<li><code>openvswitch-ovn</code>依赖<code>firewalld-filesystem</code>，通过<code>yum install firewalld-filesystem</code>安装。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要参考此安装文档 &lt;a href=&quot;http://docs.openvswitch.org/en/latest/intro/install
    
    </summary>
    
      <category term="openvswitch" scheme="http://blog.motitan.com/categories/openvswitch/"/>
    
      <category term="ovn" scheme="http://blog.motitan.com/categories/openvswitch/ovn/"/>
    
    
      <category term="openvswitch" scheme="http://blog.motitan.com/tags/openvswitch/"/>
    
      <category term="ovn" scheme="http://blog.motitan.com/tags/ovn/"/>
    
      <category term="centos7" scheme="http://blog.motitan.com/tags/centos7/"/>
    
  </entry>
  
  <entry>
    <title>enable trim of yosemite</title>
    <link href="http://blog.motitan.com/2014/10/19/enable-trim-of-yosemite/"/>
    <id>http://blog.motitan.com/2014/10/19/enable-trim-of-yosemite/</id>
    <published>2014-10-19T12:47:41.000Z</published>
    <updated>2017-03-11T02:10:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>步骤在这里，<a href="https://gist.github.com/return1/4058659" target="_blank" rel="external">https://gist.github.com/return1/4058659</a></p>
<p><code>yosemite</code>, <code>MBP 2011 early</code>，三星<code>ssd 840 evo</code>亲测开启成功。</p>
<p>命令一句一句贴到<code>terminal</code>里执行。中间会重启2次。</p>
<p><code>yosemite</code>里有一个新的安全设置<code>kext signing</code>。如果驱动被修改，没有签名，系统将拒绝载入这个驱动，开机报错。<br>现在的方法是关闭<code>kext signing</code>机制，这个配置是存在<code>NVRAM/PRAM</code>的。关闭全局<code>kext signing</code>是有安全风险的。</p>
<p>开启成功后，如果以后重置了<code>NVRAM/PRAM</code>，会导致开不了机，切记。所以在重置前，需要先关闭<code>trim</code>。</p>
<p>详细的参考，包括开机报错怎么回退，</p>
<ul>
<li><a href="http://www.cindori.org/trim-enabler-and-yosemite/" target="_blank" rel="external">http://www.cindori.org/trim-enabler-and-yosemite/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;步骤在这里，&lt;a href=&quot;https://gist.github.com/return1/4058659&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gist.github.com/return1/4058659&lt;/a&gt;&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="Mac OS X" scheme="http://blog.motitan.com/categories/Mac-OS-X/"/>
    
    
      <category term="Mac OS X" scheme="http://blog.motitan.com/tags/Mac-OS-X/"/>
    
      <category term="trim" scheme="http://blog.motitan.com/tags/trim/"/>
    
      <category term="yosemite" scheme="http://blog.motitan.com/tags/yosemite/"/>
    
  </entry>
  
  <entry>
    <title>用pylint(pyreverse)生成python代码的uml类图</title>
    <link href="http://blog.motitan.com/2014/09/21/generate-uml-of-python-code-with-pylint-pyreverse/"/>
    <id>http://blog.motitan.com/2014/09/21/generate-uml-of-python-code-with-pylint-pyreverse/</id>
    <published>2014-09-21T14:39:42.000Z</published>
    <updated>2017-03-11T04:33:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pyreverse"><a href="#pyreverse" class="headerlink" title="pyreverse"></a>pyreverse</h2><p><code>pyreverse</code>能方便的生成uml类图，<code>pylint</code>里自带了<code>pyreverse</code>这个工具。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>先安装graphviz</li>
<li>pip install pylint</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyreverse -ASmy -o png /System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/SocketServer.py -p SocketServer</div></pre></td></tr></table></figure>
<h3 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h3><a id="more"></a>
<p><img src="http://faicker.qiniudn.com/classes_SocketServer.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;pyreverse&quot;&gt;&lt;a href=&quot;#pyreverse&quot; class=&quot;headerlink&quot; title=&quot;pyreverse&quot;&gt;&lt;/a&gt;pyreverse&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pyreverse&lt;/code&gt;能方便的生成uml类图，&lt;code&gt;pylint&lt;/code&gt;里自带了&lt;code&gt;pyreverse&lt;/code&gt;这个工具。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;先安装graphviz&lt;/li&gt;
&lt;li&gt;pip install pylint&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pyreverse -ASmy -o png /System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/SocketServer.py -p SocketServer&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;图片示例&quot;&gt;&lt;a href=&quot;#图片示例&quot; class=&quot;headerlink&quot; title=&quot;图片示例&quot;&gt;&lt;/a&gt;图片示例&lt;/h3&gt;
    
    </summary>
    
      <category term="python" scheme="http://blog.motitan.com/categories/python/"/>
    
    
      <category term="python" scheme="http://blog.motitan.com/tags/python/"/>
    
      <category term="uml" scheme="http://blog.motitan.com/tags/uml/"/>
    
      <category term="pylint" scheme="http://blog.motitan.com/tags/pylint/"/>
    
  </entry>
  
  <entry>
    <title>用nginx和heroku实现一个免费的http proxy</title>
    <link href="http://blog.motitan.com/2014/09/14/%E7%94%A8nginx%E5%92%8Cheroku%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84http-proxy/"/>
    <id>http://blog.motitan.com/2014/09/14/用nginx和heroku实现一个免费的http-proxy/</id>
    <published>2014-09-14T15:24:03.000Z</published>
    <updated>2017-03-11T02:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>用nginx做forward proxy，借助于免费又支持SSL的heroku app，实现http proxy。</p>
<p>首先申请一个免费的heroku app做测试，heroku会分配一个域名，比如<code>xxx.herokuapp.com</code>，同时还支持SSL访问，这个是关键。</p>
<p>heroku的app不能直接用作代理，因为访问heroku app大概路径是，<br><code>xxx.herokuapp.com</code>解析到了heroku的前端nginx集群，然后再反向代理到自己的app。nginx会检查Host是否是heroku的app，不是的话会报404  Object Not Found。</p>
<p>思路是，</p>
<p>把要访问的网站嵌入到url里，比如<code>http://xxx.herokuapp.com/p/www.google.com</code>，然后我们在app里去请求www.google.com，然后把结果返回（包括response headers），这样我们访问<code>http://xxx.herokuapp.com/p/www.google.com</code>返回了google的内容！可以把这个app强化一下，处理一下refer，url等，完全就是heroku app的壳，里面套了其他网站的内容。</p>
<p>为了偷懒，简化这里的处理，可以在本地用nginx做一个forward proxy，把header里的host rewrite到url里。（开始是用flask写的一个程序做这个事情，后来发现还是nginx简单）</p>
<p>最后在浏览器里配置一下http proxy就行了。</p>
<p>PS,</p>
<p>heroku的免费app比较坑爹的地方是，如果一段时间inactive后，会自动关闭。</p>
<p>最后奉上nginx的配置和示例代码：<br><a id="more"></a><br>nginx server段配置如下，其他省略，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       8080;</div><div class="line">    location / &#123;</div><div class="line">        resolver 223.5.5.5;</div><div class="line">        proxy_pass https://xxx.herokuapp.com/p/$http_host$uri$is_args$args;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>app.py用的flask（网络上搜索到的一个例子改了一点，用其他也是OK的）</p>
<p>cat Procfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">web: python app.py</div></pre></td></tr></table></figure>
<p>cat requirements.txt（flask已经有新版本了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Flask==0.9</div><div class="line">Jinja2==2.6</div><div class="line">Werkzeug==0.8.3</div><div class="line">wsgiref==0.1.2</div><div class="line">requests==2.3.0</div></pre></td></tr></table></figure>
<p>cat app.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line">A simple proxy server. Usage:</div><div class="line">http://hostname:port/p/(URL to be proxied, minus protocol)</div><div class="line">For example:</div><div class="line">http://localhost:8080/p/www.google.com</div><div class="line">"""</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, abort, Response, redirect</div><div class="line"><span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> WSGIRequestHandler</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> logging</div><div class="line"></div><div class="line">app = Flask(__name__.split(<span class="string">'.'</span>)[<span class="number">0</span>])</div><div class="line">logging.basicConfig(level=logging.INFO)</div><div class="line">LOG = logging.getLogger(<span class="string">"main.py"</span>)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/&lt;path:url&gt;')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">root</span><span class="params">(url)</span>:</span></div><div class="line">    LOG.info(<span class="string">"Root route, path: %s"</span>, url)</div><div class="line">    <span class="comment"># If referred from a proxy request, then redirect to a URL with the proxy prefix.</span></div><div class="line">    <span class="comment"># This allows server-relative and protocol-relative URLs to work.</span></div><div class="line">    proxy_ref = proxy_ref_info(request)</div><div class="line">    <span class="keyword">if</span> proxy_ref:</div><div class="line">        redirect_url = <span class="string">"%s/%s%s"</span> % (proxy_ref[<span class="number">0</span>], url, (<span class="string">"?"</span> + request.query_string <span class="keyword">if</span> request.query_string <span class="keyword">else</span> <span class="string">""</span>))</div><div class="line">        LOG.info(<span class="string">"Redirecting referred URL to: %s"</span>, redirect_url)</div><div class="line">        <span class="keyword">return</span> proxy(redirect_url)</div><div class="line">    abort(<span class="number">404</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@app.route('/p/&lt;path:url&gt;')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxy</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="string">"""Fetches the specified URL and streams it out to the client.</span></div><div class="line"></div><div class="line">    If the request was referred by the proxy itself (e.g. this is an image fetch for</div><div class="line">    a previously proxied HTML page), then the original Referer is passed."""</div><div class="line">    r = get_source_rsp(url)</div><div class="line">    LOG.info(<span class="string">"Got %s response from %s"</span>,r.status_code, url)</div><div class="line">    headers = dict(r.headers)</div><div class="line">    <span class="keyword">if</span> headers.has_key(<span class="string">'transfer-encoding'</span>):</div><div class="line">        <span class="keyword">del</span>(headers[<span class="string">'transfer-encoding'</span>])</div><div class="line">    <span class="keyword">if</span> headers.has_key(<span class="string">'content-encoding'</span>):</div><div class="line">        <span class="keyword">del</span>(headers[<span class="string">'content-encoding'</span>])</div><div class="line">    <span class="keyword">return</span> Response(r.content, headers = headers)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_source_rsp</span><span class="params">(url)</span>:</span></div><div class="line">        url = <span class="string">'http://%s'</span> % url</div><div class="line">        LOG.info(<span class="string">"Fetching %s"</span>, url)</div><div class="line">        <span class="comment"># Pass original Referer for subsequent resource requests</span></div><div class="line">        proxy_ref = proxy_ref_info(request)</div><div class="line">        headers = &#123; <span class="string">"Referer"</span> : <span class="string">"http://%s/%s"</span> % (proxy_ref[<span class="number">0</span>], proxy_ref[<span class="number">1</span>])&#125; <span class="keyword">if</span> proxy_ref <span class="keyword">else</span> &#123;&#125;</div><div class="line">        <span class="comment"># Fetch the URL, and stream it back</span></div><div class="line">        LOG.info(<span class="string">"Fetching with headers: %s, %s"</span>, url, headers)</div><div class="line">        <span class="keyword">return</span> requests.get(url, stream=<span class="keyword">False</span>, params = request.args, headers=headers)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_url</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="string">"""Splits the given URL into a tuple of (protocol, host, uri)"""</span></div><div class="line">    proto, rest = url.split(<span class="string">':'</span>, <span class="number">1</span>)</div><div class="line">    rest = rest[<span class="number">2</span>:].split(<span class="string">'/'</span>, <span class="number">1</span>)</div><div class="line">    host, uri = (rest[<span class="number">0</span>], rest[<span class="number">1</span>]) <span class="keyword">if</span> len(rest) == <span class="number">2</span> <span class="keyword">else</span> (rest[<span class="number">0</span>], <span class="string">""</span>)</div><div class="line">    <span class="keyword">return</span> (proto, host, uri)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">proxy_ref_info</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="string">"""Parses out Referer info indicating the request is from a previously proxied page.</span></div><div class="line"></div><div class="line">    For example, if:</div><div class="line">        Referer: http://localhost:8080/p/google.com/search?q=foo</div><div class="line">    then the result is:</div><div class="line">        ("google.com", "search?q=foo")</div><div class="line">    """</div><div class="line">    ref = request.headers.get(<span class="string">'referer'</span>)</div><div class="line">    <span class="keyword">if</span> ref:</div><div class="line">        _, _, uri = split_url(ref)</div><div class="line">        <span class="keyword">if</span> uri.find(<span class="string">"/"</span>) &lt; <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        first, rest = uri.split(<span class="string">"/"</span>, <span class="number">1</span>)</div><div class="line">        <span class="keyword">if</span> first <span class="keyword">in</span> <span class="string">"pd"</span>:</div><div class="line">            parts = rest.split(<span class="string">"/"</span>, <span class="number">1</span>)</div><div class="line">            r = (parts[<span class="number">0</span>], parts[<span class="number">1</span>]) <span class="keyword">if</span> len(parts) == <span class="number">2</span> <span class="keyword">else</span> (parts[<span class="number">0</span>], <span class="string">""</span>)</div><div class="line">            LOG.info(<span class="string">"Referred by proxy host, uri: %s, %s"</span>, r[<span class="number">0</span>], r[<span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> r</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># Bind to PORT if defined, otherwise default to 5000.</span></div><div class="line">    port = int(os.environ.get(<span class="string">'PORT'</span>, <span class="number">5000</span>))</div><div class="line">    WSGIRequestHandler.protocol_version = <span class="string">"HTTP/1.1"</span></div><div class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=port, threaded=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用nginx做forward proxy，借助于免费又支持SSL的heroku app，实现http proxy。&lt;/p&gt;
&lt;p&gt;首先申请一个免费的heroku app做测试，heroku会分配一个域名，比如&lt;code&gt;xxx.herokuapp.com&lt;/code&gt;，同时还支持SSL访问，这个是关键。&lt;/p&gt;
&lt;p&gt;heroku的app不能直接用作代理，因为访问heroku app大概路径是，&lt;br&gt;&lt;code&gt;xxx.herokuapp.com&lt;/code&gt;解析到了heroku的前端nginx集群，然后再反向代理到自己的app。nginx会检查Host是否是heroku的app，不是的话会报404  Object Not Found。&lt;/p&gt;
&lt;p&gt;思路是，&lt;/p&gt;
&lt;p&gt;把要访问的网站嵌入到url里，比如&lt;code&gt;http://xxx.herokuapp.com/p/www.google.com&lt;/code&gt;，然后我们在app里去请求www.google.com，然后把结果返回（包括response headers），这样我们访问&lt;code&gt;http://xxx.herokuapp.com/p/www.google.com&lt;/code&gt;返回了google的内容！可以把这个app强化一下，处理一下refer，url等，完全就是heroku app的壳，里面套了其他网站的内容。&lt;/p&gt;
&lt;p&gt;为了偷懒，简化这里的处理，可以在本地用nginx做一个forward proxy，把header里的host rewrite到url里。（开始是用flask写的一个程序做这个事情，后来发现还是nginx简单）&lt;/p&gt;
&lt;p&gt;最后在浏览器里配置一下http proxy就行了。&lt;/p&gt;
&lt;p&gt;PS,&lt;/p&gt;
&lt;p&gt;heroku的免费app比较坑爹的地方是，如果一段时间inactive后，会自动关闭。&lt;/p&gt;
&lt;p&gt;最后奉上nginx的配置和示例代码：&lt;br&gt;
    
    </summary>
    
      <category term="proxy" scheme="http://blog.motitan.com/categories/proxy/"/>
    
    
      <category term="nginx" scheme="http://blog.motitan.com/tags/nginx/"/>
    
      <category term="heroku" scheme="http://blog.motitan.com/tags/heroku/"/>
    
      <category term="http proxy" scheme="http://blog.motitan.com/tags/http-proxy/"/>
    
  </entry>
  
</feed>
